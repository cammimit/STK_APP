"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mocks = void 0;
var sinon = require("sinon");
var assert = require("assert");
function isSinonStub(stub) {
    var _a;
    return (_a = stub === null || stub === void 0 ? void 0 : stub.hasOwnProperty) === null || _a === void 0 ? void 0 : _a.call(stub, 'callCount');
}
var Mocks = /** @class */ (function () {
    function Mocks(requestOptions, responseOptions, req, res, next) {
        if (requestOptions === void 0) { requestOptions = {}; }
        if (responseOptions === void 0) { responseOptions = {}; }
        if (req === void 0) { req = ExpressMocks.mockRequest(requestOptions); }
        if (res === void 0) { res = ExpressMocks.mockResponse(responseOptions); }
        if (next === void 0) { next = sinon.stub(); }
        this.req = req;
        this.res = res;
        this.next = next;
        this.initialResponse = __assign({}, res);
    }
    Mocks.prototype.test = function (router) {
        return this.execute(router);
    };
    Mocks.prototype.testError = function (router, err) {
        return this.execute(function (req, res, next) {
            return router(err, req, res, next);
        });
    };
    Mocks.prototype.execute = function (callback) {
        var _this = this;
        var promise = new Promise(function (resolve, reject) {
            var returnedPromise = undefined;
            var didReturnPromise = false;
            var asynchronous = false;
            var finishedSynchronously = false;
            var resolveOnCallback = function () {
                if (!asynchronous) {
                    finishedSynchronously = true;
                }
                else if (!didReturnPromise) {
                    resolve(_this);
                }
            };
            _this.res.redirect.callsFake(resolveOnCallback);
            _this.res.sendStatus.callsFake(resolveOnCallback);
            _this.res.json.callsFake(resolveOnCallback);
            _this.res.jsonp.callsFake(resolveOnCallback);
            _this.res.send.callsFake(resolveOnCallback);
            _this.res.sendFile.callsFake(resolveOnCallback);
            _this.res.download.callsFake(resolveOnCallback);
            _this.res.end.callsFake(resolveOnCallback);
            _this.res.render.callsFake(resolveOnCallback);
            _this.next.callsFake(resolveOnCallback);
            returnedPromise = callback(_this.req, _this.res, _this.next);
            didReturnPromise = !!returnedPromise && returnedPromise.then;
            asynchronous = true;
            if (didReturnPromise) {
                returnedPromise.then(function () { return resolve(_this); }, reject);
            }
            else if (finishedSynchronously) {
                resolve(_this);
            }
        });
        return this.createTestResult(promise.then(function () { return _this; }));
    };
    Mocks.prototype.createTestResult = function (promise) {
        var _this = this;
        var checkForResponse = function (expectedMethodName, actualMethodName, actualStub) {
            if (isSinonStub(actualStub)) {
                if (expectedMethodName === actualMethodName) {
                    assert.ok(actualStub.callCount <= 1, expectedMethodName + "() called more than once");
                    assert.strictEqual(actualStub.callCount, 1, expectedMethodName + "() not called as expected");
                }
                else {
                    assert.strictEqual(actualStub.callCount, 0, expectedMethodName + "() call was expected, but (also?) " + actualMethodName + "() was called");
                }
            }
        };
        var checkForOtherResponses = function (expectedCall) {
            checkForResponse(expectedCall, 'redirect', _this.initialResponse.redirect);
            checkForResponse(expectedCall, 'send', _this.initialResponse.send);
            checkForResponse(expectedCall, 'sendStatus', _this.initialResponse.sendStatus);
            checkForResponse(expectedCall, 'sendFile', _this.initialResponse.sendFile);
            checkForResponse(expectedCall, 'download', _this.initialResponse.download);
            checkForResponse(expectedCall, 'render', _this.initialResponse.render);
            checkForResponse(expectedCall, 'end', _this.initialResponse.end);
            checkForResponse(expectedCall, 'json', _this.initialResponse.json);
            checkForResponse(expectedCall, 'jsonp', _this.initialResponse.jsonp);
            checkForResponse(expectedCall, 'next', _this.next);
        };
        var expectJson = function (expectedJson) {
            return _this.createTestResult(promise.then(function (mocks) {
                checkForOtherResponses('json');
                sinon.assert.calledWith(_this.initialResponse.json, expectedJson);
                return mocks;
            }));
        };
        var expectJsonp = function (expectedJson) {
            return _this.createTestResult(promise.then(function (mocks) {
                checkForOtherResponses('jsonp');
                sinon.assert.calledWith(_this.initialResponse.jsonp, expectedJson);
                return mocks;
            }));
        };
        var expectSend = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.createTestResult(promise.then(function (mocks) {
                var _a;
                checkForOtherResponses('send');
                (_a = sinon.assert).calledWithExactly.apply(_a, __spreadArrays([_this.initialResponse.send], args));
                return mocks;
            }));
        };
        var expectEnd = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.createTestResult(promise.then(function (mocks) {
                var _a;
                checkForOtherResponses('end');
                (_a = sinon.assert).calledWithExactly.apply(_a, __spreadArrays([_this.initialResponse.end], args));
                return mocks;
            }));
        };
        var expectSendFile = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.createTestResult(promise.then(function (mocks) {
                var _a;
                checkForOtherResponses('sendFile');
                (_a = sinon.assert).calledWith.apply(_a, __spreadArrays([_this.initialResponse.sendFile], args));
                return mocks;
            }));
        };
        var expectDownload = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.createTestResult(promise.then(function (mocks) {
                var _a;
                checkForOtherResponses('download');
                (_a = sinon.assert).calledWith.apply(_a, __spreadArrays([_this.initialResponse.download], args));
                return mocks;
            }));
        };
        var expectRedirect = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.createTestResult(promise.then(function (mocks) {
                var _a;
                checkForOtherResponses('redirect');
                (_a = sinon.assert).calledWithExactly.apply(_a, __spreadArrays([_this.initialResponse.redirect], args));
                return mocks;
            }));
        };
        var expectRender = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return _this.createTestResult(promise.then(function (mocks) {
                var _a;
                checkForOtherResponses('render');
                (_a = sinon.assert).calledWith.apply(_a, __spreadArrays([_this.initialResponse.render], args));
                return mocks;
            }));
        };
        var expectType = function (expectedType) {
            return _this.createTestResult(promise.then(function (mocks) {
                sinon.assert.calledWith(_this.initialResponse.type, expectedType);
                return mocks;
            }));
        };
        var expectStatus = function (expectedStatus) {
            return _this.createTestResult(promise.then(function (mocks) {
                sinon.assert.calledWith(_this.initialResponse.status, expectedStatus);
                return mocks;
            }));
        };
        var expectSendStatus = function (expectedStatus) {
            return _this.createTestResult(promise.then(function (mocks) {
                checkForOtherResponses('sendStatus');
                sinon.assert.calledWith(_this.initialResponse.sendStatus, expectedStatus);
                return mocks;
            }));
        };
        var validateArgumentOfNext = function (arg, expected, messageOrCheck) {
            var _a, _b, _c;
            var errorMessage = (_a = arg === null || arg === void 0 ? void 0 : arg.message) !== null && _a !== void 0 ? _a : arg === null || arg === void 0 ? void 0 : arg.toString();
            if (arg === undefined) {
                throw new Error('expected next to have been called with any argument, but was called without');
            }
            else if (expected instanceof Error) {
                assert.strictEqual(arg, expected);
            }
            else if (typeof expected === 'string') {
                assert.strictEqual(errorMessage, expected);
            }
            else {
                assert.ok(arg instanceof expected, "expected next to have been called with instance of " + ((_b = expected.name) !== null && _b !== void 0 ? _b : 'unnamed constructor'));
            }
            if (typeof messageOrCheck === 'string') {
                assert.ok(((_c = errorMessage === null || errorMessage === void 0 ? void 0 : errorMessage.indexOf) === null || _c === void 0 ? void 0 : _c.call(errorMessage, messageOrCheck)) !== -1, "expected error message to include \"" + messageOrCheck + "\", but got \"" + errorMessage + "\"");
            }
            else if (messageOrCheck instanceof RegExp) {
                assert.ok(messageOrCheck.test(errorMessage), "expected error message to match " + messageOrCheck + ", but got \"" + errorMessage + "\"");
            }
            else if (typeof messageOrCheck === 'function') {
                messageOrCheck(arg);
            }
        };
        var expectNext = function (expected, messageOrCheck) {
            return _this.createTestResult(promise.then(function (mocks) {
                checkForOtherResponses('next');
                sinon.assert.called(_this.next);
                var args = _this.next.firstCall.args;
                if (!expected) {
                    assert.ok(!args || args.length === 0 || !args[0], "expected call to next() without arguments, but got \"" + args[0] + "\"");
                }
                else {
                    validateArgumentOfNext(args[0], expected, messageOrCheck);
                }
                return mocks;
            }));
        };
        var expectHeader = function (name, value) {
            return _this.createTestResult(promise.then(function (mocks) {
                try {
                    sinon.assert.calledWithExactly(_this.initialResponse.set, name, value);
                    return mocks;
                }
                catch (e) {
                    try {
                        sinon.assert.calledWithExactly(_this.initialResponse.setHeader, name, value);
                        return mocks;
                    }
                    catch (e2) {
                        throw new Error("Expected header '" + name + "' to have been set to '" + value + "'");
                    }
                }
            }));
        };
        return Object.assign(promise, {
            expectJson: expectJson,
            expectJsonp: expectJsonp,
            expectSend: expectSend,
            expectEnd: expectEnd,
            expectSendFile: expectSendFile,
            expectDownload: expectDownload,
            expectRedirect: expectRedirect,
            expectRender: expectRender,
            expectType: expectType,
            expectStatus: expectStatus,
            expectSendStatus: expectSendStatus,
            expectNext: expectNext,
            expectHeader: expectHeader,
        });
    };
    return Mocks;
}());
exports.Mocks = Mocks;
// parts of code from https://github.com/danawoodman/sinon-express-mock/blob/master/src/index.js
var ExpressMocks = /** @class */ (function () {
    function ExpressMocks() {
    }
    ExpressMocks.mockRequest = function (options) {
        if (options === void 0) { options = {}; }
        var ret = {};
        return Object.assign(ret, {
            accepts: sinon.stub(),
            acceptsCharsets: sinon.stub(),
            acceptsEncodings: sinon.stub(),
            acceptsLanguages: sinon.stub(),
            fflip: {
                has: sinon.stub(),
            },
            body: {},
            get: sinon.stub(),
            header: sinon.stub(),
            is: sinon.stub(),
            params: {},
            query: {},
            session: {},
            cookies: [],
        }, options);
    };
    ExpressMocks.mockResponse = function (options) {
        if (options === void 0) { options = {}; }
        var ret = {};
        return Object.assign(ret, {
            // inherited from Node ServerResponse
            // some props:
            headersSent: false,
            finished: false,
            writableEnded: false,
            writableFinished: false,
            // some methods:
            cork: sinon.stub(),
            flushHeaders: sinon.stub(),
            getHeader: sinon.stub(),
            getHeaderNames: sinon.stub(),
            getHeaders: sinon.stub(),
            hasHeader: sinon.stub(),
            removeHeader: sinon.stub(),
            setTimeout: sinon.stub().returns(ret),
            uncork: sinon.stub(),
            write: sinon.stub(),
            writeContinue: sinon.stub(),
            writeHead: sinon.stub().returns(ret),
            writeProcessing: sinon.stub(),
            // Express Response
            // props:
            locals: {},
            // methods:
            append: sinon.stub().returns(ret),
            attachment: sinon.stub().returns(ret),
            cookie: sinon.stub().returns(ret),
            clearCookie: sinon.stub().returns(ret),
            download: sinon.stub().returns(ret),
            end: sinon.stub().returns(ret),
            format: sinon.stub().returns(ret),
            get: sinon.stub(),
            json: sinon.stub().returns(ret),
            jsonp: sinon.stub().returns(ret),
            links: sinon.stub().returns(ret),
            location: sinon.stub().returns(ret),
            redirect: sinon.stub().returns(ret),
            render: sinon.stub().returns(ret),
            send: sinon.stub().returns(ret),
            sendFile: sinon.stub().returns(ret),
            sendStatus: sinon.stub().returns(ret),
            set: sinon.stub().returns(ret),
            setHeader: sinon.stub().returns(ret),
            header: sinon.stub().returns(ret),
            status: sinon.stub().returns(ret),
            type: sinon.stub().returns(ret),
            vary: sinon.stub().returns(ret),
        }, options);
    };
    ExpressMocks.create = function (requestOptions, responseOptions) {
        if (requestOptions === void 0) { requestOptions = {}; }
        if (responseOptions === void 0) { responseOptions = {}; }
        return new Mocks(requestOptions, responseOptions);
    };
    return ExpressMocks;
}());
exports.default = ExpressMocks;
